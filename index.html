<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>コード進行ジェネレーター</title>
  <style>
    body { font-family: sans-serif; margin: 2em; background: #f9f9f9; }
    input, button, select { font-size: 1em; margin: 0.5em 0; }
    #result { margin-top: 1.5em; font-size: 1.2em; }
    .chord { display: inline-block; margin: 0 0.3em; padding: 0.2em 0.5em; background: #fff; border-radius: 0.3em; border: 1px solid #ccc; }
    label { display: block; margin-top: 1em; }
  </style>
</head>
<body>
  <h1>コード進行ジェネレーター</h1>
  <label>
    最初のコード:
    <input type="text" id="startChord" value="Cmaj7" size="12">
  </label>
  <label>
    生成するコード数:
    <input type="number" id="length" value="8" step="1" min="2" max="32">
  </label>  
  <label>
    BPM:
    <input type="number" id="bpm" value="120" min="30" max="300">
  </label>
  <label>
    1コードあたりの拍数:
    <input type="number" id="beats" value="2" step="1" min="1" max="4">
  </label>
  <label>
    温度 (0.1=厳密, 1.0=普通, 2.0=独創的):
    <input type="number" id="temperature" value="1.0" step="0.1" min="0" max="100">
  </label>
  <br>
  <button id="generateBtn">生成＆再生</button>
  <button id="panicBtn" type="button" title="停止">停止</button>
  <div id="warning" style="margin-top:1em;"></div>
  <div id="result"></div>
  <script>
    let model = null;
    let currentAudioCtx = null;

    const CHORD_DEGREES = {
      "":         [0, 4, 7],
      "m":        [0, 3, 7],
      "o":        [0, 3, 6],
      "o7":       [0, 3, 6, 9],
      "aug":      [0, 4, 8],
      "maug":     [0, 3, 8],
      "sus":      [0, 5, 7],
      "6":        [0, 4, 7, 9],
      "m6":       [0, 3, 7, 9],
      "mb6":      [0, 3, 7, 8],
      "add9":     [0, 4, 7, 14],
      "69":       [0, 4, 7, 9, 14],
      "m69":      [0, 3, 7, 9, 14],
      "7":        [0, 4, 7, 10],
      "7sus":     [0, 5, 7, 10],
      "7b5":      [0, 4, 6, 10],
      "7b5b9":    [0, 4, 6, 10, 13],
      "7b5#9":    [0, 4, 6, 10, 15],
      "7#5":      [0, 4, 8, 10],
      "7#5#9":    [0, 4, 8, 10, 15],
      "7b9":      [0, 4, 7, 10, 13],
      "7b9sus":   [0, 5, 7, 10, 13],
      "7b9#5":    [0, 4, 8, 10, 13],
      "7b9#9":    [0, 4, 7, 10, 13, 15],
      "7b9#11":   [0, 4, 7, 10, 13, 18],
      "7b9b13":   [0, 4, 7, 10, 13, 20],
      "7#9":      [0, 4, 7, 10, 15],
      "7#9#11":   [0, 4, 7, 10, 15, 18],
      "7#11":     [0, 4, 7, 10, 18],
      "7b13":     [0, 4, 7, 10, 20],
      "7b13sus":  [0, 5, 7, 10, 20],
      "7alt":     [0, 4, 7, 10, 13, 15, 18, 20],
      "maj7":     [0, 4, 7, 11],
      "maj7#5":   [0, 4, 8, 11],
      "maj7#11":  [0, 4, 7, 11, 18],
      "m7":       [0, 3, 7, 10],
      "m7b5":     [0, 3, 6, 10],
      "mMaj7":    [0, 3, 7, 11],
      "m7b9":     [0, 3, 6, 10, 13],
      "9":        [0, 4, 7, 10, 14],
      "9sus":     [0, 5, 7, 10, 14],
      "9b5":      [0, 4, 6, 10, 14],
      "9#5":      [0, 4, 8, 10, 14],
      "9#11":     [0, 4, 7, 10, 14, 18],
      "m9":       [0, 3, 7, 10, 14],
      "maj9":     [0, 4, 7, 11, 14],
      "maj9#11":  [0, 4, 7, 11, 14, 18],
      "m11":      [0, 3, 7, 10, 14, 17],
      "13":       [0, 4, 7, 10, 14, 21],
      "13sus":    [0, 5, 7, 10, 14, 21],
      "13b9":     [0, 4, 7, 10, 13, 21],
      "13#9":     [0, 4, 7, 10, 15, 21],
      "13#11":    [0, 4, 7, 10, 14, 18, 21],
      "maj13":    [0, 4, 7, 11, 14, 21],
    };
    const NOTE_NAMES = ['C', 'Db', 'D', 'Eb', 'E', 'F', 'Gb', 'G', 'Ab', 'A', 'Bb', 'B'];

    function getChordNotes(chordName) {
      const MIN_NOTE = 41; // F2
      let upper_bottom, chord_type, root_note;
      if (chordName.includes('/')) {
        const [upper, root] = chordName.split('/', 2);
        const m = upper.match(/^([A-G]b?)(.*)$/);
        if (!m) return null;
        upper_bottom = m[1];
        chord_type = m[2];
        root_note = root;
      } else {
        const n = chordName.match(/^([A-G]b?)(.*)$/);
        if (!n) return null;
        upper_bottom = n[1];
        chord_type = n[2];
        root_note = upper_bottom;
      }
      const mod_MN = MIN_NOTE % 12;
      const R_NOTE_NAMES = NOTE_NAMES.slice(mod_MN).concat(NOTE_NAMES.slice(0, mod_MN));
      const root_note_number = MIN_NOTE + R_NOTE_NAMES.indexOf(root_note);
      const upper_bottom_note_number = MIN_NOTE + 12 + R_NOTE_NAMES.indexOf(upper_bottom);
      const degrees = CHORD_DEGREES[chord_type];
      if (!degrees) return null;
      const upper_chord_numbers = degrees.map(degree => upper_bottom_note_number + degree);
      const notes = [root_note_number - 12, root_note_number].concat(upper_chord_numbers);
      return notes;
    }

    function sampleWithTemperature(probDict, temperature) {
      const chords = Object.keys(probDict);
      const probs = Object.values(probDict);
      if (temperature <= 0.0) {
        return chords[probs.indexOf(Math.max(...probs))];
      }
      const eps = 1e-8;
      const logits = probs.map(p => Math.log(p + eps) / temperature);
      const maxLogit = Math.max(...logits);
      const exp_logits = logits.map(l => Math.exp(l - maxLogit));
      const total = exp_logits.reduce((a, b) => a + b, 0);
      const weights = exp_logits.map(e => e / total);
      let r = Math.random(), acc = 0;
      for (let i = 0; i < chords.length; i++) {
        acc += weights[i];
        if (r < acc) return chords[i];
      }
      return chords[chords.length - 1];
    }

    function generateProgression(model, seedSequence, length, temperature) {
      const progression = [...seedSequence];
      for (let i = 0; i < length - 1; i++) {
        let found = false;
        const key = progression.slice(-1).join('-');
        const probs = model[key];
        if (probs) {
          const nextChord = sampleWithTemperature(probs, temperature);
          progression.push(nextChord);
          found = true;
        }
        if (!found) break;
      }
      return progression;
    }

    async function playChordProgression(chordNames, bpm, beats) {
      if (currentAudioCtx) {
        try { currentAudioCtx.close(); } catch {}
      }
      const ctx = new (window.AudioContext || window.webkitAudioContext)();
      currentAudioCtx = ctx;
      const beatSec = 60 / bpm;
      let now = ctx.currentTime + 0.1;
      for (const chord of chordNames) {
        if (ctx !== currentAudioCtx) break;
        const notes = getChordNotes(chord);
        if (!notes) continue;
        for (const midi of notes) {
          const freq = 440 * Math.pow(2, (midi - 69) / 12);
          const osc = ctx.createOscillator();
          const gain = ctx.createGain();
          osc.type = 'triangle';
          osc.frequency.value = freq;
          gain.gain.value = 0.12;
          osc.connect(gain).connect(ctx.destination);
          osc.start(now);
          osc.stop(now + beatSec * beats * 0.95);
          gain.gain.setValueAtTime(0.12, now);
          gain.gain.linearRampToValueAtTime(0.0, now + beatSec * beats * 0.95);
        }
        now += beatSec * beats;
      }
      await new Promise(res => setTimeout(res, beatSec * beats * chordNames.length * 1000 + 200));
      if (ctx === currentAudioCtx) {
        ctx.close();
        currentAudioCtx = null;
      }
    }

    fetch('model.json')
      .then(res => res.json())
      .then(json => { model = json; })
      .catch(() => {
        document.getElementById('result').textContent = 'モデルファイルの読み込みに失敗しました。';
      });

    function getRandomChordFromModel(model) {
      const keys = Object.keys(model);
      const chordKeys = keys.filter(k => !k.includes('-'));
      if (chordKeys.length === 0) return null;
      const idx = Math.floor(Math.random() * chordKeys.length);
      return chordKeys[idx];
    }

    document.getElementById('generateBtn').onclick = async function() {
      document.getElementById('warning').textContent = '';
      if (!model) {
        document.getElementById('result').textContent = 'モデルがまだ読み込まれていません。';
        return;
      }
      
      let startChord = document.getElementById('startChord').value.trim();
      const lengthStr = document.getElementById('length').value;
      const bpmStr = document.getElementById('bpm').value;
      const beatsStr = document.getElementById('beats').value;
      const temperatureStr = document.getElementById('temperature').value;

      let warning = '';
      if (!lengthStr || isNaN(lengthStr) || parseInt(lengthStr) < 2) {
        warning += '生成するコード数を2以上で入力してください。\n';
      }
      if (!bpmStr || isNaN(bpmStr) || parseInt(bpmStr) < 30) {
        warning += 'BPMを30以上で入力してください。\n';
      }
      if (!beatsStr || isNaN(beatsStr) || parseInt(beatsStr) < 1) {
        warning += '1コードあたりの拍数を1以上で入力してください。\n';
      }
      if (!temperatureStr || isNaN(temperatureStr) || parseFloat(temperatureStr) < 0.1) {
        warning += '温度を0.1以上で入力してください。\n';
      }
      
      if (!startChord) {
        startChord = getRandomChordFromModel(model);
        if (!startChord) {
          warning += 'モデルにコードが含まれていません。\n';
        }
      }
      if (warning) {
        document.getElementById('warning').textContent = warning.trim();
        return;
      }

      const length = parseInt(lengthStr);
      const bpm = parseInt(bpmStr);
      const beats = parseInt(beatsStr);
      const temperature = parseFloat(temperatureStr);

      const seedContext = [startChord];
      if (!seedContext) {
        document.getElementById('result').textContent = `開始コード '${startChord}' に基づく初期文脈の補完に失敗しました。`;
        return;
      }
      const result = generateProgression(model, seedContext, length, temperature);

      document.getElementById('result').innerHTML =
        '<b>生成されたコード進行:</b><br>' +
        result.map(c => `<span class="chord">${c}</span>`).join(' — ') +
        '<br><br><b>各コードの構成音:</b><br>' +
        result.map(chord => {
          const notes = getChordNotes(chord);
          if (notes) {
            const noteNames = notes.map(n => `${NOTE_NAMES[n % 12]}${Math.floor(n / 12) - 1}`);
            return `<span class="chord">${chord}</span>: [${noteNames.join(', ')}]`;
          } else {
            return `<span class="chord">${chord}</span>: (対応表未定義)`;
          }
        }).join('<br>');

      await playChordProgression(result, bpm, beats);
    };

    document.getElementById('panicBtn').onclick = function() {
      if (currentAudioCtx) {
        try { currentAudioCtx.close(); } catch {}
        currentAudioCtx = null;
      }
    };
  </script>
</body>
</html>
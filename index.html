<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>コード進行ジェネレーター</title>
  <style>
    body { font-family: sans-serif; margin: 2em; background: #f9f9f9; }
    input, button, select { font-size: 1em; margin: 0.5em 0; }
    #result { margin-top: 1.5em; font-size: 1.2em; }
    .chord { display: inline-block; margin: 0 0.3em; padding: 0.2em 0.5em; background: #fff; border-radius: 0.3em; border: 1px solid #ccc; }
    label { display: block; margin-top: 1em; }
  </style>
</head>
<body>
  <h1>コード進行ジェネレーター</h1>
  <label>
    最初のコード:
    <input type="text" id="startChord" value="Cmaj7" size="12">
  </label>
  <label>
    BPM:
    <input type="number" id="bpm" value="120" min="30" max="300">
  </label>
  <label>
    1コードあたりの拍数:
    <input type="number" id="beats" value="2" step="1" min="1" max="4">
  </label>
  <label>
    温度 (0.1=厳密, 1.0=普通, 2.0=独創的):
    <input type="number" id="temperature" value="1.0" step="0.1" min="0" max="100">
  </label>
  <br>
  <button id="generateBtn">生成＆再生</button>
  <button id="panicBtn" type="button" title="停止">停止</button>
  <div id="warning" style="margin-top:1em;"></div>
  <div id="result"></div>
  <script>
    let model = null;
    let currentAudioCtx = null;
    let isPlaying = false;
    let progression = [];
    const MAX_HISTORY = 8; // 表示する履歴数

    const CHORD_DEGREES = {
      "":         [0, 4, 7],
      "m":        [0, 3, 7],
      "o":        [0, 3, 6],
      "o7":       [0, 3, 6, 9],
      "aug":      [0, 4, 8],
      "maug":     [0, 3, 8],
      "sus":      [0, 5, 7],
      "6":        [0, 4, 7, 9],
      "m6":       [0, 3, 7, 9],
      "mb6":      [0, 3, 7, 8],
      "add9":     [0, 4, 7, 14],
      "69":       [0, 4, 7, 9, 14],
      "m69":      [0, 3, 7, 9, 14],
      "7":        [0, 4, 7, 10],
      "7sus":     [0, 5, 7, 10],
      "7b5":      [0, 4, 6, 10],
      "7b5b9":    [0, 4, 6, 10, 13],
      "7b5#9":    [0, 4, 6, 10, 15],
      "7#5":      [0, 4, 8, 10],
      "7#5#9":    [0, 4, 8, 10, 15],
      "7b9":      [0, 4, 7, 10, 13],
      "7b9sus":   [0, 5, 7, 10, 13],
      "7b9#5":    [0, 4, 8, 10, 13],
      "7b9#9":    [0, 4, 7, 10, 13, 15],
      "7b9#11":   [0, 4, 7, 10, 13, 18],
      "7b9b13":   [0, 4, 7, 10, 13, 20],
      "7#9":      [0, 4, 7, 10, 15],
      "7#9#11":   [0, 4, 7, 10, 15, 18],
      "7#11":     [0, 4, 7, 10, 18],
      "7b13":     [0, 4, 7, 10, 20],
      "7b13sus":  [0, 5, 7, 10, 20],
      "7alt":     [0, 4, 7, 10, 13, 15, 18, 20],
      "maj7":     [0, 4, 7, 11],
      "maj7#5":   [0, 4, 8, 11],
      "maj7#11":  [0, 4, 7, 11, 18],
      "m7":       [0, 3, 7, 10],
      "m7b5":     [0, 3, 6, 10],
      "mMaj7":    [0, 3, 7, 11],
      "m7b9":     [0, 3, 6, 10, 13],
      "9":        [0, 4, 7, 10, 14],
      "9sus":     [0, 5, 7, 10, 14],
      "9b5":      [0, 4, 6, 10, 14],
      "9#5":      [0, 4, 8, 10, 14],
      "9#11":     [0, 4, 7, 10, 14, 18],
      "m9":       [0, 3, 7, 10, 14],
      "maj9":     [0, 4, 7, 11, 14],
      "maj9#11":  [0, 4, 7, 11, 14, 18],
      "m11":      [0, 3, 7, 10, 14, 17],
      "13":       [0, 4, 7, 10, 14, 21],
      "13sus":    [0, 5, 7, 10, 14, 21],
      "13b9":     [0, 4, 7, 10, 13, 21],
      "13#9":     [0, 4, 7, 10, 15, 21],
      "13#11":    [0, 4, 7, 10, 14, 18, 21],
      "maj13":    [0, 4, 7, 11, 14, 21],
    };
    const NOTE_NAMES = ['C', 'Db', 'D', 'Eb', 'E', 'F', 'Gb', 'G', 'Ab', 'A', 'Bb', 'B'];

    function getChordNotes(chordName) {
      const MIN_NOTE = 41; // F2
      let upper_bottom, chord_type, root_note;
      if (chordName.includes('/')) {
        const [upper, root] = chordName.split('/', 2);
        const m = upper.match(/^([A-G]b?)(.*)$/);
        if (!m) return null;
        upper_bottom = m[1];
        chord_type = m[2];
        root_note = root;
      } else {
        const n = chordName.match(/^([A-G]b?)(.*)$/);
        if (!n) return null;
        upper_bottom = n[1];
        chord_type = n[2];
        root_note = upper_bottom;
      }
      const mod_MN = MIN_NOTE % 12;
      const R_NOTE_NAMES = NOTE_NAMES.slice(mod_MN).concat(NOTE_NAMES.slice(0, mod_MN));
      const root_note_number = MIN_NOTE + R_NOTE_NAMES.indexOf(root_note);
      const upper_bottom_note_number = MIN_NOTE + 12 + R_NOTE_NAMES.indexOf(upper_bottom);
      const degrees = CHORD_DEGREES[chord_type];
      if (!degrees) return null;
      const upper_chord_numbers = degrees.map(degree => upper_bottom_note_number + degree);
      const notes = [root_note_number - 12, root_note_number].concat(upper_chord_numbers);
      return notes;
    }

    function sampleWithTemperature(probDict, temperature) {
      const chords = Object.keys(probDict);
      const probs = Object.values(probDict);
      if (temperature <= 0.0) {
        return chords[probs.indexOf(Math.max(...probs))];
      }
      const eps = 1e-8;
      const logits = probs.map(p => Math.log(p + eps) / temperature);
      const maxLogit = Math.max(...logits);
      const exp_logits = logits.map(l => Math.exp(l - maxLogit));
      const total = exp_logits.reduce((a, b) => a + b, 0);
      const weights = exp_logits.map(e => e / total);
      let r = Math.random(), acc = 0;
      for (let i = 0; i < chords.length; i++) {
        acc += weights[i];
        if (r < acc) return chords[i];
      }
      return chords[chords.length - 1];
    }

    function getNextChord(model, prevChord, temperature) {
      // progressionの末尾2つが同じ場合、その和音を除外
      let excludeChord = null;
      if (progression.length >= 2) {
        const last = progression[progression.length - 1];
        const prev = progression[progression.length - 2];
        if (last === prev) {
          excludeChord = last;
        }
      }
      const key = prevChord;
      let probs = model[key];
      if (probs) {
        // 除外対象があれば除外
        if (excludeChord) {
          probs = Object.fromEntries(
            Object.entries(probs).filter(([chord]) => chord !== excludeChord)
          );
          // すべて除外されて空になった場合は元に戻す
          if (Object.keys(probs).length === 0) {
            probs = model[key];
          }
        }
        return sampleWithTemperature(probs, temperature);
      }
      // fallback: ランダムに1つ
      const keys = Object.keys(model);
      let chordKeys = keys.filter(k => !k.includes('-'));
      if (excludeChord) {
        chordKeys = chordKeys.filter(k => k !== excludeChord);
        if (chordKeys.length === 0) {
          chordKeys = keys.filter(k => !k.includes('-'));
        }
      }
      if (chordKeys.length === 0) return null;
      const idx = Math.floor(Math.random() * chordKeys.length);
      return chordKeys[idx];
    }

    let scheduledTimeout = null; // 追加: 再生スケジューラ管理用

    async function playRealtimeProgression(model, startChord, bpm, beats, temperature) {
      if (currentAudioCtx) {
        try { currentAudioCtx.close(); } catch {}
      }
      isPlaying = true;
      progression = [startChord];
      let prevChord = startChord;
      const beatSec = 60 / bpm;
      let ctx = new (window.AudioContext || window.webkitAudioContext)();
      currentAudioCtx = ctx;
      let chordStartTime = ctx.currentTime + 0.1;

      updateResult();

      async function scheduleNext() {
        if (!isPlaying) {
          if (currentAudioCtx) {
            try { currentAudioCtx.close(); } catch {}
            currentAudioCtx = null;
          }
          return;
        }
        // 再生
        const chord = progression[progression.length - 1];
        const notes = getChordNotes(chord);
        if (notes) {
          playChordScheduled(ctx, notes, chordStartTime, beatSec, beats);
        }
        // 次のコードを生成
        const nextChord = getNextChord(model, prevChord, temperature);
        if (!nextChord) {
          isPlaying = false;
          if (currentAudioCtx) {
            try { currentAudioCtx.close(); } catch {}
            currentAudioCtx = null;
          }
          return;
        }
        progression.push(nextChord);
        if (progression.length > MAX_HISTORY) {
          progression = progression.slice(-MAX_HISTORY);
        }
        prevChord = nextChord;
        updateResult();

        chordStartTime += beatSec * beats;
        // setTimeoutで次のスケジュール
        const now = ctx.currentTime;
        const waitMs = Math.max(0, (chordStartTime - now - 0.02) * 1000); // 余裕を持って
        scheduledTimeout = setTimeout(scheduleNext, waitMs);
      }

      scheduleNext();
    }

    function playChordScheduled(ctx, notes, startTime, beatSec, beats) {
      // 各ノートのoscillator/gainを管理して停止できるようにする
      if (!ctx._oscList) ctx._oscList = [];
      for (const midi of notes) {
        const freq = 440 * Math.pow(2, (midi - 69) / 12);
        const osc = ctx.createOscillator();
        const gain = ctx.createGain();
        osc.type = 'triangle';
        osc.frequency.value = freq;
        gain.gain.value = 0.12;
        osc.connect(gain).connect(ctx.destination);
        osc.start(startTime);
        osc.stop(startTime + beatSec * beats * 0.95);
        gain.gain.setValueAtTime(0.12, startTime);
        gain.gain.linearRampToValueAtTime(0.0, startTime + beatSec * beats * 0.95);
        ctx._oscList.push(osc);
      }
    }

    function updateResult() {
      // progressionの最後のコードの構成音のみ表示
      const lastChord = progression[progression.length - 1];
      const notes = getChordNotes(lastChord);
      let noteStr = '';
      if (notes) {
        const noteNames = notes.map(n => `${NOTE_NAMES[n % 12]}${Math.floor(n / 12) - 1}`);
        noteStr = `<span class="chord">${lastChord}</span>: [${noteNames.join(', ')}]`;
      } else {
        noteStr = `<span class="chord">${lastChord}</span>: (対応表未定義)`;
      }
      document.getElementById('result').innerHTML =
        '<b>コード進行:</b><br>' +
        progression.map((c, i) => {
          if (i === progression.length - 1) {
            return `<span class="chord" style="background:#ffe;">${c}</span>`;
          } else {
            return `<span class="chord">${c}</span>`;
          }
        }).join(' — ') +
        '<br><br><b>現在のコードの構成音:</b><br>' +
        noteStr;
    }

    fetch('model.json')
      .then(res => res.json())
      .then(json => { model = json; })
      .catch(() => {
        document.getElementById('result').textContent = 'モデルファイルの読み込みに失敗しました。';
      });

    function getRandomChordFromModel(model) {
      const keys = Object.keys(model);
      const chordKeys = keys.filter(k => !k.includes('-'));
      if (chordKeys.length === 0) return null;
      const idx = Math.floor(Math.random() * chordKeys.length);
      return chordKeys[idx];
    }

    document.getElementById('generateBtn').onclick = async function() {
      document.getElementById('warning').textContent = '';
      if (!model) {
        document.getElementById('result').textContent = 'モデルがまだ読み込まれていません。';
        return;
      }

      let startChord = document.getElementById('startChord').value.trim();
      const bpmStr = document.getElementById('bpm').value;
      const beatsStr = document.getElementById('beats').value;
      const temperatureStr = document.getElementById('temperature').value;

      let warning = '';
      if (!bpmStr || isNaN(bpmStr)) {
        warning += 'BPMを30以上で入力してください。\n';
      }
      if (!beatsStr || isNaN(beatsStr)) {
        warning += '1コードあたりの拍数を1以上で入力してください。\n';
      }
      if (!temperatureStr || isNaN(temperatureStr)) {
        warning += '温度を0.1以上で入力してください。\n';
      }

      if (!startChord) {
        startChord = getRandomChordFromModel(model);
        if (!startChord) {
          warning += 'モデルにコードが含まれていません。\n';
        }
      }
      if (warning) {
        document.getElementById('warning').textContent = warning.trim();
        return;
      }

      const bpm = parseInt(bpmStr);
      const beats = parseInt(beatsStr);
      const temperature = parseFloat(temperatureStr);

      isPlaying = false;
      if (scheduledTimeout) clearTimeout(scheduledTimeout);
      await new Promise(res => setTimeout(res, 100));
      isPlaying = true;
      playRealtimeProgression(model, startChord, bpm, beats, temperature);
    };

    document.getElementById('panicBtn').onclick = function() {
      isPlaying = false;
      if (scheduledTimeout) clearTimeout(scheduledTimeout);
      if (currentAudioCtx) {
        // すべてのoscillatorを即時停止
        if (currentAudioCtx._oscList) {
          for (const osc of currentAudioCtx._oscList) {
            try { osc.stop(); } catch {}
          }
          currentAudioCtx._oscList = [];
        }
        try { currentAudioCtx.close(); } catch {}
        currentAudioCtx = null;
      }
    };
  </script>
</body>
</html>